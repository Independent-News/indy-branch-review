{"version":3,"file":"5004.27fc9ab3.iframe.bundle.js","mappings":";AAkCA;AACA;AACA;AA+CA;AAZA;AACA;AACA;AAIA","sources":["webpack://@indy/flow-web/./app/types/CustomPropTypes.js"],"sourcesContent":["/* cspell:ignore requireable */\n\nimport {\n  REGEXP_MUSTACHE_PLACEHOLDER,\n  REGEXP_AMP_ACTION,\n  REGEXP_EMPTY_PARAGRAPH,\n  REGEXP_EMPTY_STRING,\n  REGEXP_URL_REMOTE,\n  REGEXP_URL_LOCAL,\n  REGEXP_PRICE,\n} from '#app/constants/regexps';\n\nimport { minify } from '#app/util/taggedTemplates';\n\nconst isFalsy = (value) => [undefined, null].includes(value);\n\n/**\n * \"Invalid prop `propName` supplied to `componentName`.\n * Expected `expected` e.g. `example`.\n * Received `received`.\"\n * @param {string} propName The name of the prop being validated\n * @param {string} componentName The name of the component being validated\n * @param {string} expected The expected prop-type\n * @param {string} [received] The actual prop-type\n * @param {string} [example] An example of the expected prop-type\n * @returns {string} Preformatted error message\n */\nconst message = (\n  propName,\n  componentName,\n  expected,\n  received = '',\n  example = '',\n) => minify`\n  Invalid prop \\`${propName}\\` supplied to ${componentName}.\n  Expected ${expected}${example ? ` e.g. \\`${example}\\`` : ''}.\n  Received ${received || typeof received}.\n`;\n\n/**\n * Validates prop values\n * @name PropTypesValidator\n * @function\n * @param {string} props Component props object\n * @param {string} propName Name of the prop being validated\n * @param {string} componentName Name of the component being validated\n * @link https://reactjs.org/docs/typechecking-with-proptypes.html\n */\n\n/**\n * Creates a prop-type with its corresponding 'required' alternative\n * @param {import('prop-types').Validator} validator PropTypes custom validator\n * @returns {import('prop-types').Requireable} Prop-type validator with\n * chainable \"isRequired\" version\n */\nfunction generatePropType(validator) {\n  const propType = (props, propName, componentName) => {\n    const value = props[propName];\n\n    if (isFalsy(value)) {\n      return;\n    }\n\n    return validator(props, propName, componentName);\n  };\n\n  propType.isRequired = (props, propName, componentName) => {\n    const value = props[propName];\n\n    if (isFalsy(value)) {\n      return new Error(minify`\n        The prop \\`${propName}\\` is marked as required\n        in \\`${componentName}\\`,\n        but its value is \\`${value}\\`.\n      `);\n    }\n\n    return validator(props, propName, componentName);\n  };\n\n  return propType;\n}\n\nconst validators = {\n  mustachePlaceholder(props, propName, componentName) {\n    if (!REGEXP_MUSTACHE_PLACEHOLDER.test(props[propName])) {\n      return new Error(\n        message(\n          propName,\n          componentName,\n          'mustache placeholder',\n          props[propName],\n          '{{foo}}',\n        ),\n      );\n    }\n  },\n  ampAction(props, propName, componentName) {\n    if (!REGEXP_AMP_ACTION.test(props[propName])) {\n      return new Error(\n        message(\n          propName,\n          componentName,\n          'AMP action',\n          props[propName],\n          '`tap:...` or `select:...`',\n        ),\n      );\n    }\n  },\n  meaningfulString(props, propName, componentName) {\n    const value = props[propName];\n    const meaningless = [REGEXP_EMPTY_PARAGRAPH, REGEXP_EMPTY_STRING];\n\n    if (typeof value !== 'string') {\n      return new Error(\n        message(propName, componentName, 'type `string`', typeof value),\n      );\n    }\n\n    if (meaningless.some((pattern) => pattern.test(value))) {\n      return new Error(\n        message(propName, componentName, 'meaningful content', value),\n      );\n    }\n  },\n  emptyString(props, propName, componentName) {\n    const value = props[propName];\n\n    if (typeof value !== 'string') {\n      return new Error(\n        message(propName, componentName, 'type `string`', typeof value),\n      );\n    }\n\n    if (!REGEXP_EMPTY_STRING.test(value)) {\n      return new Error(message(propName, componentName, 'empty string', value));\n    }\n  },\n  nonEmptyArray(props, propName, componentName) {\n    const value = props[propName];\n\n    if (!Array.isArray(value)) {\n      return new Error(\n        message(propName, componentName, 'type `Array`', typeof value),\n      );\n    }\n\n    if (value.length < 1) {\n      return new Error(message(propName, componentName, 'non-empty array'));\n    }\n  },\n  url(props, propName, componentName) {\n    if (\n      !REGEXP_URL_REMOTE.test(props[propName]) &&\n      !REGEXP_URL_LOCAL.test(props[propName])\n    ) {\n      return new Error(\n        message(\n          propName,\n          componentName,\n          'URL',\n          props[propName],\n          'http://sub.domain.tld` or `/internal/path',\n        ),\n      );\n    }\n  },\n  currency(props, propName, componentName) {\n    const value = props[propName];\n    const float = parseFloat(value);\n\n    if (isNaN(float) || !REGEXP_PRICE.test(value)) {\n      return new Error(\n        message(\n          propName,\n          componentName,\n          'A currency value without symbol',\n          props[propName],\n          '\"2.99\"` or `2.99` or `2',\n        ),\n      );\n    }\n  },\n};\n\nexport default Object.entries(validators).reduce(\n  (acc, [propType, validator]) => {\n    acc[propType] = generatePropType(validator);\n    return acc;\n  },\n  {},\n);\n\n/**\n * @callback ConditionCallback\n * @param {object} props\n * @returns {boolean}\n */\n\n/**\n * This function creates a prop-type that is required if the condition is met\n * @param {PropTypes.Requireable} requireable\n * @param {ConditionCallback} condition\n * @returns\n */\nexport const isRequiredIf =\n  (requireable, condition) => (props, propName, componentName) => {\n    if (condition(props)) {\n      return requireable.isRequired(props, propName, componentName);\n    }\n\n    return null;\n  };\n"],"names":[],"sourceRoot":""}